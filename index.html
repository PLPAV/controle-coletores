<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Controle de Coletores — 72 × 16</title>
<style>
  :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
  body { margin:0; background:#f4f4f8; color:#111; padding:18px; }
  h1 { margin:0 0 12px; font-size:18px; }

  .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .pill { background:#eef0f7; border:1px solid #dfe3f1; padding:6px 10px; border-radius:999px; font-size:13px; }

  .box { background:#fff; border:1px solid #e7e7ee; border-radius:12px; padding:12px; margin:12px 0; box-shadow:0 1px 1px rgba(0,0,0,.03); }
  .grid { display:grid; grid-template-columns:1fr; gap:12px; }
  @media (min-width: 980px){ .grid { grid-template-columns:1fr 1fr; } }

  h2 { margin:0 0 8px; font-size:15px; }

  table { width:100%; border-collapse: collapse; font-size:13px; }
  th, td { border-bottom:1px solid #efeff6; padding:7px 6px; text-align:left; vertical-align: top; }
  th { font-size:12px; background:#fafafa; }

  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

  .kpis { display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px; }
  @media (min-width: 980px){ .kpis { grid-template-columns: repeat(5, minmax(0,1fr)); } }

  .kpi { border:1px solid #eee; border-radius:12px; padding:10px; background:#fafafa; }
  .kpi .v { font-size:20px; font-weight:700; }
  .kpi .t { font-size:12px; color:#444; }

  select {
    padding:8px 10px;
    border:1px solid #d9d9e6;
    border-radius:10px;
    background:white;
    font-size:13px;
    line-height: 1.2;
    min-width: 120px;
    cursor: pointer;
    position: relative;
    z-index: 5;
  }

  .muted { color:#666; font-size:12px; }
  .controlRow { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
</style>
</head>
<body>

<h1>Controle de Coletores (72 nodes × 16 coletores)</h1>

<div class="row">
  <span class="pill"><b>Atualização:</b> <span id="lastUpdate" class="mono">—</span></span>
  <span class="pill"><b>Total (filtro):</b> <span id="total" class="mono">0</span></span>
</div>

<div class="grid">
  <div class="box">
    <h2>Resumo</h2>
    <div class="kpis">
      <div class="kpi"><div class="v" id="kTotal">0</div><div class="t">Ocorrências</div></div>
      <div class="kpi"><div class="v" id="kWasherOnly">0</div><div class="t">Arruela (somente)</div></div>
      <div class="kpi"><div class="v" id="kSensorOnly">0</div><div class="t">Sensor (somente)</div></div>
      <div class="kpi"><div class="v" id="kBoth">0</div><div class="t">Arruela + Sensor</div></div>
      <div class="kpi"><div class="v" id="kFuros">0</div><div class="t">Quantidade de furos</div></div>
    </div>

    <div class="muted" style="margin-top:10px">
      Total de arruelas: <b id="kTotalWashers">0</b> &nbsp;|&nbsp;
      Total de sensores: <b id="kTotalSensors">0</b>
    </div>
  </div>

  <div class="box">
    <h2>Ocorrências por vento</h2>
    <table>
      <thead><tr><th>Vento</th><th>Ocorrências</th><th>%</th></tr></thead>
      <tbody id="byWind"></tbody>
    </table>
  </div>
</div>

<div class="grid">
  <div class="box">
    <div class="controlRow">
      <h2 style="margin:0">Nodes (mais ocorrências)</h2>
      <span class="muted">Node:</span>
      <select id="nodeFocusTop">
        <option value="ALL">Todos</option>
      </select>
    </div>

    <table>
      <thead>
        <tr>
          <th>Node</th>
          <th>Ocorrências</th>
          <th>Arruela (somente)</th>
          <th>Sensor (somente)</th>
          <th>Arruela+Sensor</th>
          <th>Furos</th>
        </tr>
      </thead>
      <tbody id="topNodes"></tbody>
    </table>
  </div>

  <div class="box">
    <div class="controlRow">
      <h2 style="margin:0">Incidência (Node–Coletor)</h2>
      <span class="muted">Node:</span>
      <select id="nodeFocusPairs">
        <option value="ALL">Todos</option>
      </select>
    </div>

    <table>
      <thead>
        <tr>
          <th>Node</th><th>Coletor</th><th>Ocorrências</th>
          <th>Arruela</th><th>Sensor</th>
          <th>Ventos</th>
          <th>Datas ocorrência</th>
          <th>Datas arruela</th>
          <th>Datas sensor</th>
          <th>Furos</th>
          <th>Tamanhos</th>
          <th>Datas furo</th>
        </tr>
      </thead>
      <tbody id="topPairs"></tbody>
    </table>
  </div>
</div>

<div class="grid">
  <div class="box">
    <h2>Incidência pós-ajuste — Sensores reincidentes</h2>
    <table>
      <thead><tr><th>Node</th><th>Coletor</th><th>Ocorrências</th><th>Ventos</th><th>Datas ocorrência</th></tr></thead>
      <tbody id="postSensorPairs"></tbody>
    </table>
  </div>

  <div class="box">
    <h2>Incidência pós-ajuste — Arruelas reincidentes</h2>
    <table>
      <thead><tr><th>Node</th><th>Coletor</th><th>Ocorrências</th><th>Ventos</th><th>Datas ocorrência</th></tr></thead>
      <tbody id="postWasherPairs"></tbody>
    </table>
  </div>
</div>

<script>
/* ==========================
   ÁREA QUE VOCÊ EDITA
========================== */
const DATA_ATUALIZACAO = "11/02/2026";

const entradas = [
  "46-4 vento 100% jan/2026",
  "52-4 vento 100% jan/2026",
  "58-6 vento 100% jan/2026",
  "44-6 vento 100% jan/2026",
  "33-3 vento 100% jan/2026",
  "53-3(arruela) vento 100% jan/2026",
  "11-9 vento 100% jan/2026",
  "3-7 vento 100% jan/2026",
  "9-10(arruela:04/02/2026) vento 100% 04/02/2026",
  "53-7(arruela) vento 50% jan/2026",
  "45-13(arruela) vento 50% jan/2026",
  "29-16(arruela:03/02/2026) vento 50% 03/02/2026",
  "58-4(arruela:03/02/2026 e sensor:03/02/2026) vento 50% 03/02/2026",
  "39-8(arruela:03/02/2026 e sensor:05/02/2026) vento 50% 03/02/2026",
  "23-7(arruela:03/02/2026) 03/02/2026",
  "11-10(arruela:03/02/2026) 03/02/2026",
  "60-2(arruela:09/02/2026 e sensor:09/02/2026) vento 50% 09/02/2026",
  "50-15(arruela:11/02/2026) vento 100% 11/02/2026"
];

const entradasPosAjusteSensor = [
  // Ex.: "58-4 vento 50% 10/02/2026"
];

const entradasPosAjusteArruela = [
  "39-8 vento 50% 04/02/2026",
  "39-8 vento 50% 04/02/2026",
  "39-8 vento 100% 05/02/2026",
];

const entradasFurosplaca = [
  "39-8 vento 100% furo 5mm 05/02/2026",
  "60-2 vento 50% furo 5mm 09/02/2026"
];
/* ==========================
   FIM DA ÁREA DE EDIÇÃO
========================== */

document.getElementById("lastUpdate").textContent = DATA_ATUALIZACAO;

/* ==========================
   Datas flexíveis:
   - dd/mm/aaaa
   - mm/aaaa
   - jan/aaaa, fev/aaaa, ...
========================== */
const MONTHS_PT = {
  jan: 1, fev: 2, mar: 3, abr: 4, mai: 5, jun: 6,
  jul: 7, ago: 8, set: 9, out:10, nov:11, dez:12
};

const FLEX_DATE_RE = /\b(\d{1,2}\/\d{1,2}\/\d{4}|\d{1,2}\/\d{4}|(?:jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)\s*\/\s*\d{4})\b/gi;

function normToken(t){
  return String(t).trim().toLowerCase().replace(/\s+/g, "");
}

function dateToKey(token){
  if (!token) return 0;
  const t = normToken(token);

  if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(t)){
    const [d,m,y] = t.split("/").map(Number);
    return (y*10000 + m*100 + d);
  }
  if (/^\d{1,2}\/\d{4}$/.test(t)){
    const [m,y] = t.split("/").map(Number);
    return (y*10000 + m*100 + 0);
  }
  const mm = t.match(/^(jan|fev|mar|abr|mai|jun|jul|ago|set|out|nov|dez)\/(\d{4})$/);
  if (mm){
    const m = MONTHS_PT[mm[1]] || 0;
    const y = Number(mm[2]);
    return (y*10000 + m*100 + 0);
  }
  return 0;
}

function formatDates(list){
  if (!list || list.length === 0) return "—";
  const clean = list.filter(Boolean).map(s => String(s).trim()).filter(Boolean);
  if (!clean.length) return "—";
  return clean.slice().sort((a,b)=>dateToKey(a)-dateToKey(b)).join(", ");
}

function extractParensText(txt){
  return Array.from(String(txt).matchAll(/\(([^)]+)\)/g)).map(m => m[1] || "");
}
function removeParens(txt){
  return String(txt).replace(/\([^)]*\)/g, " ");
}
function lastFlexDateOutsideParens(txt){
  const clean = removeParens(txt);
  const hits = Array.from(clean.matchAll(FLEX_DATE_RE)).map(m => m[1]);
  return hits.length ? hits[hits.length - 1].trim() : "";
}

/* FIX: datas de arruela não pegam datas do sensor e vice-versa */
function parseAdjDatesFromParens(txt){
  const parensJoined = extractParensText(txt).join(" | ");
  const low = parensJoined.toLowerCase();

  const washerDates = [];
  const sensorDates = [];

  for (const m of low.matchAll(/arruela\s*:\s*(.*?)(?=\bsensor\s*:|$)/g)){
    const chunk = m[1] || "";
    const hits = Array.from(chunk.matchAll(FLEX_DATE_RE)).map(x => x[1]);
    if (hits.length) washerDates.push(...hits.map(s => s.trim()));
  }

  for (const m of low.matchAll(/sensor\s*:\s*(.*?)(?=\barruela\s*:|$)/g)){
    const chunk = m[1] || "";
    const hits = Array.from(chunk.matchAll(FLEX_DATE_RE)).map(x => x[1]);
    if (hits.length) sensorDates.push(...hits.map(s => s.trim()));
  }

  const hasWasher = low.includes("arruela");
  const hasSensor = low.includes("sensor");

  return { washerDates, sensorDates, hasWasher, hasSensor };
}

function parseEntry(raw){
  const txt = String(raw).trim();
  if (!txt) return null;

  let wind = 0;
  const mw = txt.match(/vento\s*(0|50|100)\s*%?/i);
  if (mw && mw[1]) wind = Number(mw[1]);

  const mbase = txt.match(/^(\d+)\s*-\s*(\d+)/);
  if (!mbase) return null;
  const node = Number(mbase[1]);
  const coletor = Number(mbase[2]);

  const occDate = lastFlexDateOutsideParens(txt);
  const adj = parseAdjDatesFromParens(txt);

  const hasWasher = adj.washerDates.length ? true : adj.hasWasher;
  const hasSensor = adj.sensorDates.length ? true : adj.hasSensor;

  const valid =
    Number.isFinite(node) && Number.isFinite(coletor) &&
    node >= 1 && node <= 72 &&
    coletor >= 1 && coletor <= 16 &&
    [0,50,100].includes(wind);

  return valid ? {
    wind, node, coletor,
    washer: hasWasher ? 1 : 0,
    sensor: hasSensor ? 1 : 0,
    occDate,
    washerAdjDates: adj.washerDates,
    sensorAdjDates: adj.sensorDates
  } : null;
}

function flattenAll(list){
  const out = [];
  for (const r of list){
    const e = parseEntry(r);
    if (e) out.push(e);
  }
  return out;
}

function aggInit(){
  return {
    count:0,
    washerOnly:0, sensorOnly:0, both:0,
    washerAny:0, sensorAny:0,
    winds:[],
    occDates:[],
    washerAdjDates:[],
    sensorAdjDates:[],
    holesCount:0,
    holeSizes:[],
    holeDates:[]
  };
}
function aggAdd(agg, e){
  agg.count++;

  const w = !!e.washer, s = !!e.sensor;

  if (w) agg.washerAny++;
  if (s) agg.sensorAny++;

  if (w && !s) agg.washerOnly++;
  else if (!w && s) agg.sensorOnly++;
  else if (w && s) agg.both++;

  agg.winds.push(e.wind);

  if (e.occDate) agg.occDates.push(e.occDate);
  if (e.washerAdjDates?.length) agg.washerAdjDates.push(...e.washerAdjDates);
  if (e.sensorAdjDates?.length) agg.sensorAdjDates.push(...e.sensorAdjDates);
}

function computeByNode(list){
  const byNode = new Map();
  for (const e of list){
    if (!byNode.has(e.node)) byNode.set(e.node, aggInit());
    aggAdd(byNode.get(e.node), e);
  }
  return Array.from(byNode.entries()).sort((a,b)=>b[1].count-a[1].count);
}
function computeByPair(list){
  const byPair = new Map();
  for (const e of list){
    const k = `${e.node}-${e.coletor}`;
    if (!byPair.has(k)) byPair.set(k, aggInit());
    aggAdd(byPair.get(k), e);
  }
  return Array.from(byPair.entries()).sort((a,b)=>b[1].count-a[1].count);
}

function populateNodeSelect(selectEl, nodes, keepValue=true){
  const prev = keepValue ? selectEl.value : "ALL";
  const wasAll = (prev === "ALL");

  while (selectEl.options.length > 1) selectEl.remove(1);
  for (const n of nodes){
    const opt = document.createElement("option");
    opt.value = String(n);
    opt.textContent = String(n);
    selectEl.appendChild(opt);
  }

  // Se estava em ALL, permanece ALL (assim a lista sempre atualiza e mostra novos nodes)
  if (wasAll) { selectEl.value = "ALL"; return; }

  const hasPrev = Array.from(selectEl.options).some(o => o.value === prev);
  selectEl.value = hasPrev ? prev : "ALL";
}

function formatSizes(list){
  if (!list || list.length === 0) return "—";
  return list.join(", ");
}

/* ---- Furos ---- */
function parseFuro(raw){
  const txt = String(raw).trim();
  if (!txt) return null;

  let wind = 0;
  const mw = txt.match(/vento\s*(0|50|100)\s*%?/i);
  if (mw && mw[1]) wind = Number(mw[1]);

  const mbase = txt.match(/^(\d+)\s*-\s*(\d+)/);
  if (!mbase) return null;
  const node = Number(mbase[1]);
  const coletor = Number(mbase[2]);

  let size = "";
  const ms = txt.match(/furo\s*([0-9]+(?:[.,][0-9]+)?)\s*mm/i);
  if (ms && ms[1]) size = (ms[1].replace(",", ".") + "mm");

  const holeDate = lastFlexDateOutsideParens(txt);

  const valid =
    Number.isFinite(node) && Number.isFinite(coletor) &&
    node >= 1 && node <= 72 &&
    coletor >= 1 && coletor <= 16 &&
    [0,50,100].includes(wind);

  return valid ? { wind, node, coletor, size, holeDate } : null;
}
function flattenFuros(list){
  const out = [];
  for (const r of list){
    const e = parseFuro(r);
    if (e) out.push(e);
  }
  return out;
}
function buildHoleMaps(furos){
  const byPair = new Map();
  const byNode = new Map();

  for (const f of furos){
    const key = `${f.node}-${f.coletor}`;

    if (!byPair.has(key)) byPair.set(key, { count:0, sizes:[], dates:[] });
    const p = byPair.get(key);
    p.count++;
    if (f.size) p.sizes.push(f.size);
    if (f.holeDate) p.dates.push(f.holeDate);

    if (!byNode.has(f.node)) byNode.set(f.node, { count:0, sizes:[], dates:[] });
    const n = byNode.get(f.node);
    n.count++;
    if (f.size) n.sizes.push(f.size);
    if (f.holeDate) n.dates.push(f.holeDate);
  }
  return { byPair, byNode };
}

function renderByWind(list){
  const counts = new Map([[0,0],[50,0],[100,0]]);
  for (const e of list) counts.set(e.wind, (counts.get(e.wind)||0)+1);
  const total = list.length || 1;

  const tbody = document.getElementById("byWind");
  tbody.innerHTML = "";
  for (const w of [0,50,100]){
    const c = counts.get(w) || 0;
    const pct = Math.round((c/total)*1000)/10;
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${w}%</td><td><b>${c}</b></td><td>${pct}%</td>`;
    tbody.appendChild(tr);
  }
}

function renderTopNodes(entries, focusValue){
  const tbody = document.getElementById("topNodes");
  tbody.innerHTML = "";

  // ✅ Em ALL: mostra TODOS (assim node 60 aparece sem precisar mexer no select)
  const show = (focusValue === "ALL")
    ? entries
    : entries.filter(([node]) => String(node) === focusValue);

  for (const [node, agg] of show){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${node}</td>
      <td><b>${agg.count}</b></td>
      <td>${agg.washerOnly}</td>
      <td>${agg.sensorOnly}</td>
      <td>${agg.both}</td>
      <td>${agg.holesCount || 0}</td>
    `;
    tbody.appendChild(tr);
  }

  if (show.length === 0){
    tbody.innerHTML = `<tr><td colspan="6">Sem dados para o node selecionado.</td></tr>`;
  }
}

function renderPairs(entries, focusValue, tbodyId, mode){
  const tbody = document.getElementById(tbodyId);
  tbody.innerHTML = "";

  const filtered = (focusValue === "ALL")
    ? entries
    : entries.filter(([pair]) => String(pair).startsWith(focusValue + "-"));

  const show = filtered.slice(0, 25);

  for (const [pair, agg] of show){
    const [node, coletor] = pair.split("-");
    const windsSorted = agg.winds.slice().sort((a,b)=>a-b).map(w=>`${w}%`).join(", ");

    const tr = document.createElement("tr");
    if (mode === "main"){
      tr.innerHTML = `
        <td>${node}</td><td>${coletor}</td>
        <td><b>${agg.count}</b></td>
        <td>${agg.washerAny}</td><td>${agg.sensorAny}</td>
        <td class="mono">${windsSorted || "—"}</td>
        <td class="mono">${formatDates(agg.occDates)}</td>
        <td class="mono">${formatDates(agg.washerAdjDates)}</td>
        <td class="mono">${formatDates(agg.sensorAdjDates)}</td>
        <td>${agg.holesCount || 0}</td>
        <td class="mono">${formatSizes(agg.holeSizes)}</td>
        <td class="mono">${formatDates(agg.holeDates)}</td>
      `;
    } else {
      tr.innerHTML = `
        <td>${node}</td><td>${coletor}</td>
        <td><b>${agg.count}</b></td>
        <td class="mono">${windsSorted || "—"}</td>
        <td class="mono">${formatDates(agg.occDates)}</td>
      `;
    }
    tbody.appendChild(tr);
  }

  if (show.length === 0){
    tbody.innerHTML = `<tr><td colspan="${mode==='main' ? 12 : 5}">Sem dados.</td></tr>`;
  }
}

/* ==========================
   UPDATE (combina pós-incidência)
========================== */
function update(){
  const baseAll = flattenAll(entradas);
  const postSensorAll = flattenAll(entradasPosAjusteSensor);
  const postWasherAll = flattenAll(entradasPosAjusteArruela);

  const allCombined = [...baseAll, ...postSensorAll, ...postWasherAll];

  const wind = document.getElementById("windFilter").value;
  const filtered = (wind === "ALL") ? allCombined : allCombined.filter(e => e.wind === Number(wind));

  document.getElementById("kTotal").textContent = String(filtered.length);

  // Resumo por coletor (status acumulado)
  const statusPorPar = new Map();
  for (const e of filtered){
    const key = `${e.node}-${e.coletor}`;
    if (!statusPorPar.has(key)) statusPorPar.set(key, { hasWasher:false, hasSensor:false });
    const st = statusPorPar.get(key);
    if (e.washer) st.hasWasher = true;
    if (e.sensor) st.hasSensor = true;
  }

  let washerOnly=0, sensorOnly=0, both=0;
  for (const st of statusPorPar.values()){
    if (st.hasWasher && st.hasSensor) both++;
    else if (st.hasWasher && !st.hasSensor) washerOnly++;
    else if (!st.hasWasher && st.hasSensor) sensorOnly++;
  }

  document.getElementById("kWasherOnly").textContent = String(washerOnly);
  document.getElementById("kSensorOnly").textContent = String(sensorOnly);
  document.getElementById("kBoth").textContent = String(both);

  document.getElementById("kTotalWashers").textContent = String(washerOnly + both);
  document.getElementById("kTotalSensors").textContent = String(sensorOnly + both);

  renderByWind(filtered);

  // Furos por vento (separado)
  const furosAll = flattenFuros(entradasFurosplaca);
  const furosFiltered = (wind === "ALL") ? furosAll : furosAll.filter(f => f.wind === Number(wind));
  document.getElementById("kFuros").textContent = String(furosFiltered.length);

  const holeMaps = buildHoleMaps(furosFiltered);

  // Selects
  const nodeList = Array.from(new Set(filtered.map(e => e.node))).sort((a,b)=>a-b);
  const selTop = document.getElementById("nodeFocusTop");
  const selPairs = document.getElementById("nodeFocusPairs");
  populateNodeSelect(selTop, nodeList, true);
  populateNodeSelect(selPairs, nodeList, true);

  // Nodes
  const byNode = computeByNode(filtered);
  for (const [node, agg] of byNode){
    const h = holeMaps.byNode.get(node);
    agg.holesCount = h ? h.count : 0;
    agg.holeSizes = h ? h.sizes.slice() : [];
  }
  renderTopNodes(byNode, selTop.value);

  // Incidência por par
  const byPair = computeByPair(filtered);
  for (const [pair, agg] of byPair){
    const h = holeMaps.byPair.get(pair);
    agg.holesCount = h ? h.count : 0;
    agg.holeSizes = h ? h.sizes.slice() : [];
    agg.holeDates = h ? h.dates.slice() : [];
  }
  renderPairs(byPair, selPairs.value, "topPairs", "main");

  // Pós separado
  renderPairs(computeByPair(postSensorAll), "ALL", "postSensorPairs", "post");
  renderPairs(computeByPair(postWasherAll), "ALL", "postWasherPairs", "post");
}

document.getElementById("windFilter").addEventListener("change", update);
document.getElementById("nodeFocusTop").addEventListener("change", update);
document.getElementById("nodeFocusPairs").addEventListener("change", update);

update();
</script>

</body>
</html>
